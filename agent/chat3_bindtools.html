<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>LangGraph bindtoolsæµ‹è¯•</title>
  <style>
    body { font-family: Arial; margin: 40px; }
    #chat { border: 1px solid #a3e2f9; height: 500px; overflow-y: auto; padding: 10px; background: #fafafa; }
    #inputBox { width: 70%; padding: 6px; }
    button { padding: 6px 12px; }
    .plan-box {
      background: #afcfeb;
      border-left: 4px solid #2196F3;
      padding: 8px 12px;
      margin: 6px 0;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <h3>LangGraph bindtoolsæµ‹è¯•</h3>
  <div id="chat"></div>
  <input id="inputBox" placeholder="è¾“å…¥æ¶ˆæ¯ï¼Œå›è½¦å‘é€" onkeypress="handleKeyPress(event)" />
  <!-- ä¸Šä¼ æ–‡ä»¶æŒ‰é’® -->
  <input type="file" id="fileInput" style="margin-left: 10px;" />
  <button onclick="sendMessage()">å‘é€</button>

  <script>
    const API_BASE = "http://127.0.0.1:2024";   // ä¸ä½ çš„ langgraph dev åœ°å€ä¸€è‡´

    let threadId = null;

    /* å¤„ç†å›è½¦é”®äº‹ä»¶ */
    function handleKeyPress(event) {
      if (event.key === "Enter") {
        event.preventDefault();  // é˜²æ­¢å›è½¦é”®åœ¨è¾“å…¥æ¡†ä¸­äº§ç”Ÿæ¢è¡Œ
        sendMessage();
      }
    }
    /* 1. åˆ›å»ºçº¿ç¨‹ï¼ˆåªéœ€ä¸€æ¬¡ï¼‰ */
    async function createThread() {
      const res = await fetch(`${API_BASE}/threads`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({})
      });
      if (!res.ok) throw new Error("åˆ›å»ºçº¿ç¨‹å¤±è´¥");
      const data = await res.json();
      threadId = data.thread_id;
      console.log("çº¿ç¨‹ ID:", threadId);
    }
    
    /* ä¸Šä¼ æ–‡ä»¶åˆ°åç«¯æ¥å£ */
    async function uploadFile(file) {
      try {
        // åˆ›å»º FormData å¯¹è±¡
        const formData = new FormData();
        formData.append("file", file);
        
        // è°ƒç”¨ä¸Šä¼ æ¥å£
        const uploadUrl = "http://127.0.0.1:8006/upload"; // upload.py æœåŠ¡åœ°å€
        const response = await fetch(uploadUrl, {
          method: "POST",
          body: formData
        });
        
        if (!response.ok) {
          throw new Error(`ä¸Šä¼ å¤±è´¥: ${response.status}`);
        }
        
        // è¿”å›ä¸Šä¼ ç»“æœ
        return await response.json();
      } catch (error) {
        console.error("æ–‡ä»¶ä¸Šä¼ å¤±è´¥:", error);
        appendChat("system", `æ–‡ä»¶ä¸Šä¼ å¤±è´¥: ${error.message}`);
        return null;
      }
    }

    /* 2. å‘é€æ¶ˆæ¯å¹¶æµå¼æ¥æ”¶ */
    async function sendMessage() {
      const msg = inputBox.value.trim();
      const fileInput = document.getElementById("fileInput");
      const file = fileInput.files[0];
      
      if (!msg && !file) return;
      
      inputBox.value = "";
      fileInput.value = "";
      
      // æ„å»ºæ¶ˆæ¯å†…å®¹
      let messageContent = msg;
      let files = [];
      
      if (file) {
        // å…ˆè°ƒç”¨ä¸Šä¼ æ¥å£ä¸Šä¼ æ–‡ä»¶
        const uploadResult = await uploadFile(file);
        if (uploadResult) {
          const fileInfo = {
            id: uploadResult.file_id,
            name: uploadResult.filename,
            type: uploadResult.content_type,
            size: file.size,
            path: uploadResult.path  // åç«¯è¿”å›çš„æ–‡ä»¶è·¯å¾„
          };
          files.push(fileInfo);
          
          // èŠå¤©ç•Œé¢æ˜¾ç¤ºç”¨æˆ·è¾“å…¥å’Œæ–‡ä»¶ä¿¡æ¯
          appendChat("user", `${msg || 'å·²ä¸Šä¼ æ–‡ä»¶'}\n [æ–‡ä»¶: ${file.name}, ${formatFileSize(file.size)}]`);
        }
      } else {
        appendChat("user", msg);
      }
      
      console.log("å½“å‰ID:", threadId);
      
      // æ„å»ºæ¶ˆæ¯å¯¹è±¡
      const messageObj = {
        role: "user",
        content: messageContent
      };
      
      // 3. å‘èµ·æµå¼è¯·æ±‚ï¼ˆcustom æ¨¡å¼ï¼Œåç«¯ç”¨ writer å‘ JSONï¼‰
      const resp = await fetch(`${API_BASE}/threads/${threadId}/runs/stream`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          assistant_id: "bridge_bindtools",   // ä½ çš„ graph æ³¨å†Œå
          input: { 
            messages: [messageObj],
            files: files  // æ–‡ä»¶ä¿¡æ¯ä½œä¸ºç‹¬ç«‹å­—æ®µ
          },
          stream_mode: "custom"            // å¯¹åº”åç«¯ writer(...) 
        })
      });

      if (!resp.ok) {
        console.error("è¿è¡Œå¤±è´¥", resp.status, resp.statusText);
        return;
      }

      /* 4. é€å—è§£æ */
      const reader = resp.body.getReader();
      const decoder = new TextDecoder();
      let buffer = "";

      appendChat("bot", "");          // å…ˆå ä¸€è¡Œ
      const botSpan = document.querySelector('#chat > div:last-child > span');

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split("\n");
        buffer = lines.pop() ?? "";   // æœ€åä¸€è¡Œå¯èƒ½ä¸å®Œæ•´ï¼Œç•™åˆ°ä¸‹æ¬¡
        for (const l of lines) {
          if (l.startsWith("data: ")) {
            const jsonText = l.slice(6).trim();
            if (!jsonText) continue;  // å¿ƒè·³è¡Œ
            try {
              const chunk = JSON.parse(jsonText);
              // æŒ‰åç«¯ writer çš„å­—æ®µç»“æ„è§£æ
              if (chunk.event_type === "custom_stream") {
                botSpan.insertAdjacentText("beforeend", chunk.reply);
                
              }
              else if (chunk.event === "plan_start") {
                appendPhase(chunk.text);
                console.log("æ”¶åˆ°:", chunk.text);
              }
              else if (chunk.event === "plan_final") {   // åç«¯ä¸€æ¬¡æ€§æ¨æˆå“
                renderPlan(chunk.plan);
                console.log("æ”¶åˆ°:", chunk.plan);
              }
            } catch (e) {
              console.warn("è§£æå¤±è´¥", jsonText, e);
            }
          }
        }
      }
      console.log("æµå¼è¾“å‡ºå®Œæ¯•");
    }

    /* å·¥å…·å‡½æ•° */
    function appendChat(role, text) {
      const div = document.createElement("div");
      div.style.margin = "4px 0";
      // å°†æ¢è¡Œç¬¦è½¬æ¢ä¸º <br> æ ‡ç­¾
      const formattedText = text.replace(/\n/g, "<br>");
      div.innerHTML = `<b>${role}:</b> <span>${formattedText}</span>`;
      document.getElementById("chat").appendChild(div);
      div.scrollIntoView();
    }

    /* æ¸²æŸ“è®¡åˆ’å¡ç‰‡ */
    function renderPlan(planArr) {
      const box = document.createElement("div");
      box.className = "plan-box";
      box.innerHTML = "<b>ğŸ“‹ æ‰§è¡Œè®¡åˆ’</b><ol>" +
        planArr.map(p => `<li><code>${p.tool}</code> ${p.desc||""}</li>`).join("") +
        "</ol>";
      document.getElementById("chat").appendChild(box);
      box.scrollIntoView();
    }

    /* çº¯æ–‡æœ¬é˜¶æ®µæç¤º */
    function appendPhase(text) {
      const div = document.createElement("div");
      div.style.color = "#666";
      div.textContent = text;
      document.getElementById("chat").appendChild(div);
      div.scrollIntoView();
    }
    
    /* è¯»å–æ–‡ä»¶ä¸º base64 */
    function readFileAsBase64(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => {
          // ç§»é™¤ data URL å‰ç¼€ï¼ˆå¦‚ "data:image/png;base64,"ï¼‰
          const base64 = reader.result.split(',')[1];
          resolve(base64);
        };
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }
    
    /* æ ¼å¼åŒ–æ–‡ä»¶å¤§å° */
    function formatFileSize(bytes) {
      if (bytes === 0) return '0 Bytes';
      const k = 1024;
      const sizes = ['Bytes', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
    }
    
    /* åˆå§‹åŒ– */
    (async () => {
      await createThread();
    })();
  </script>
</body>
</html>